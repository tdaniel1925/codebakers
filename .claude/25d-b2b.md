# B2B EXPERT
# Module: 25d-b2b.md
# Load with: 00-core.md
# Covers: Multi-tenancy, organizations, RBAC, SSO, API keys, audit logs

---

## üè¢ B2B EXPERT PERSPECTIVE

When building B2B applications, focus on multi-tenancy,
role-based access, and enterprise requirements.

### Multi-Tenant Schema

```typescript
// db/schema/b2b.ts
import { pgTable, uuid, text, timestamp, boolean, jsonb, integer } from 'drizzle-orm/pg-core';

// Organizations (Tenants)
export const organizations = pgTable('organizations', {
  id: uuid('id').primaryKey().defaultRandom(),
  name: text('name').notNull(),
  slug: text('slug').unique().notNull(),
  domain: text('domain').unique(),
  logo: text('logo'),
  settings: jsonb('settings').$type<{
    branding?: { primaryColor?: string; logo?: string; favicon?: string };
    features?: { ssoEnabled?: boolean; apiAccessEnabled?: boolean; auditLogEnabled?: boolean };
    limits?: { maxUsers?: number; maxStorage?: number; maxApiCalls?: number };
  }>(),
  subscriptionTier: text('subscription_tier').default('free'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
});

// Organization Members
export const organizationMembers = pgTable('organization_members', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  userId: uuid('user_id').notNull(),
  role: text('role').notNull(), // 'owner', 'admin', 'member', 'viewer'
  title: text('title'),
  department: text('department'),
  invitedBy: uuid('invited_by'),
  invitedAt: timestamp('invited_at'),
  joinedAt: timestamp('joined_at').defaultNow(),
  lastActiveAt: timestamp('last_active_at'),
});

// Invitations
export const invitations = pgTable('invitations', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  email: text('email').notNull(),
  role: text('role').notNull(),
  token: text('token').unique().notNull(),
  invitedBy: uuid('invited_by').notNull(),
  expiresAt: timestamp('expires_at').notNull(),
  acceptedAt: timestamp('accepted_at'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

// Teams
export const teams = pgTable('teams', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  description: text('description'),
  parentTeamId: uuid('parent_team_id').references(() => teams.id),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});

// API Keys
export const apiKeys = pgTable('api_keys', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull().references(() => organizations.id, { onDelete: 'cascade' }),
  name: text('name').notNull(),
  keyPrefix: text('key_prefix').notNull(),
  keyHash: text('key_hash').notNull(),
  scopes: jsonb('scopes').$type<string[]>().default([]),
  lastUsedAt: timestamp('last_used_at'),
  expiresAt: timestamp('expires_at'),
  createdBy: uuid('created_by').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  revokedAt: timestamp('revoked_at'),
});

// Audit Log
export const auditLogs = pgTable('audit_logs', {
  id: uuid('id').primaryKey().defaultRandom(),
  organizationId: uuid('organization_id').notNull(),
  userId: uuid('user_id'),
  action: text('action').notNull(),
  resourceType: text('resource_type').notNull(),
  resourceId: uuid('resource_id'),
  metadata: jsonb('metadata').$type<Record<string, unknown>>(),
  ipAddress: text('ip_address'),
  userAgent: text('user_agent'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});
```

### Role-Based Access Control (RBAC)

```typescript
// lib/rbac/permissions.ts

export const PERMISSIONS = {
  'org:read': 'View organization details',
  'org:update': 'Update organization settings',
  'org:delete': 'Delete organization',
  'org:billing': 'Manage billing',
  'members:read': 'View members',
  'members:invite': 'Invite new members',
  'members:update': 'Update member roles',
  'members:remove': 'Remove members',
  'teams:read': 'View teams',
  'teams:create': 'Create teams',
  'teams:update': 'Update teams',
  'teams:delete': 'Delete teams',
  'projects:read': 'View projects',
  'projects:create': 'Create projects',
  'projects:update': 'Update projects',
  'projects:delete': 'Delete projects',
  'api_keys:read': 'View API keys',
  'api_keys:create': 'Create API keys',
  'api_keys:revoke': 'Revoke API keys',
  'audit:read': 'View audit logs',
} as const;

export type Permission = keyof typeof PERMISSIONS;

export const ROLE_PERMISSIONS: Record<string, Permission[]> = {
  owner: Object.keys(PERMISSIONS) as Permission[],
  admin: [
    'org:read', 'org:update', 'members:read', 'members:invite', 'members:update', 'members:remove',
    'teams:read', 'teams:create', 'teams:update', 'teams:delete',
    'projects:read', 'projects:create', 'projects:update', 'projects:delete',
    'api_keys:read', 'api_keys:create', 'api_keys:revoke', 'audit:read',
  ],
  member: ['org:read', 'members:read', 'teams:read', 'projects:read', 'projects:create', 'projects:update'],
  viewer: ['org:read', 'members:read', 'teams:read', 'projects:read'],
};

export function hasPermission(role: string, permission: Permission): boolean {
  const permissions = ROLE_PERMISSIONS[role];
  if (!permissions) return false;
  return permissions.includes(permission);
}

export function requirePermission(permission: Permission) {
  return async (req: Request, ctx: { params: { orgId: string } }) => {
    const session = await getSession();
    if (!session?.user) throw new Error('Unauthorized');

    const membership = await getMembership(session.user.id, ctx.params.orgId);
    if (!membership) throw new Error('Not a member of this organization');
    if (!hasPermission(membership.role, permission)) throw new Error(`Missing permission: ${permission}`);

    return { membership, session };
  };
}
```

### API Key Service

```typescript
// services/b2b/api-key-service.ts
import { db } from '@/db';
import { apiKeys } from '@/db/schema';
import { eq, and, isNull } from 'drizzle-orm';
import crypto from 'crypto';

export class ApiKeyService {
  static async createApiKey(
    organizationId: string,
    name: string,
    scopes: string[],
    createdBy: string,
    expiresAt?: Date
  ): Promise<{ id: string; key: string; prefix: string }> {
    const rawKey = crypto.randomBytes(32).toString('hex');
    const prefix = rawKey.substring(0, 8);
    const keyHash = crypto.createHash('sha256').update(rawKey).digest('hex');

    const [created] = await db.insert(apiKeys).values({
      organizationId, name, keyPrefix: prefix, keyHash, scopes, createdBy, expiresAt,
    }).returning();

    return { id: created.id, key: `sk_live_${rawKey}`, prefix };
  }

  static async validateApiKey(key: string): Promise<{
    valid: boolean;
    organizationId?: string;
    scopes?: string[];
    error?: string;
  }> {
    if (!key.startsWith('sk_live_')) {
      return { valid: false, error: 'Invalid key format' };
    }

    const rawKey = key.replace('sk_live_', '');
    const keyHash = crypto.createHash('sha256').update(rawKey).digest('hex');

    const [apiKey] = await db.select().from(apiKeys)
      .where(and(eq(apiKeys.keyHash, keyHash), isNull(apiKeys.revokedAt))).limit(1);

    if (!apiKey) return { valid: false, error: 'Invalid API key' };
    if (apiKey.expiresAt && new Date(apiKey.expiresAt) < new Date()) {
      return { valid: false, error: 'API key expired' };
    }

    await db.update(apiKeys).set({ lastUsedAt: new Date() }).where(eq(apiKeys.id, apiKey.id));

    return { valid: true, organizationId: apiKey.organizationId, scopes: apiKey.scopes as string[] };
  }

  static async revokeApiKey(keyId: string, organizationId: string): Promise<void> {
    await db.update(apiKeys).set({ revokedAt: new Date() })
      .where(and(eq(apiKeys.id, keyId), eq(apiKeys.organizationId, organizationId)));
  }
}
```

### SSO Integration (SAML)

```typescript
// services/b2b/sso-service.ts
import { db } from '@/db';
import { organizations } from '@/db/schema';
import { eq } from 'drizzle-orm';
import { nanoid } from 'nanoid';

interface SAMLConfig {
  entryPoint: string;
  issuer: string;
  cert: string;
  callbackUrl: string;
}

export class SSOService {
  static async configureSAML(organizationId: string, config: SAMLConfig): Promise<void> {
    await db.update(organizations).set({
      settings: sql`jsonb_set(COALESCE(settings, '{}'), '{sso}', ${JSON.stringify({
        provider: 'saml',
        entryPoint: config.entryPoint,
        issuer: config.issuer,
        cert: config.cert,
        callbackUrl: config.callbackUrl,
        enabled: true,
      })})`,
      updatedAt: new Date(),
    }).where(eq(organizations.id, organizationId));
  }

  static generateSPMetadata(organizationSlug: string): string {
    const baseUrl = process.env.NEXT_PUBLIC_APP_URL;
    const acsUrl = `${baseUrl}/api/auth/saml/${organizationSlug}/callback`;
    const entityId = `${baseUrl}/api/auth/saml/${organizationSlug}/metadata`;

    return `<?xml version="1.0"?>
<EntityDescriptor xmlns="urn:oasis:names:tc:SAML:2.0:metadata" entityID="${entityId}">
  <SPSSODescriptor AuthnRequestsSigned="false" WantAssertionsSigned="true" protocolSupportEnumeration="urn:oasis:names:tc:SAML:2.0:protocol">
    <NameIDFormat>urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress</NameIDFormat>
    <AssertionConsumerService Binding="urn:oasis:names:tc:SAML:2.0:bindings:HTTP-POST" Location="${acsUrl}" index="0"/>
  </SPSSODescriptor>
</EntityDescriptor>`;
  }

  static async initiateLogin(organizationSlug: string): Promise<string> {
    const [org] = await db.select().from(organizations).where(eq(organizations.slug, organizationSlug)).limit(1);

    if (!org?.settings?.sso?.enabled) throw new Error('SSO not configured for this organization');

    const sso = org.settings.sso;
    const requestId = `_${nanoid()}`;
    const issueInstant = new Date().toISOString();

    const samlRequest = `<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol" ID="${requestId}" Version="2.0" IssueInstant="${issueInstant}" Destination="${sso.entryPoint}" AssertionConsumerServiceURL="${sso.callbackUrl}">
  <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">${sso.issuer}</saml:Issuer>
</samlp:AuthnRequest>`;

    const encoded = Buffer.from(samlRequest).toString('base64');
    return `${sso.entryPoint}?SAMLRequest=${encodeURIComponent(encoded)}`;
  }
}
```

---
